
// Relative Path: planning\todolist.py
from __future__ import annotations

from enum import Enum
import os
from pathlib import Path
from datetime import datetime
from typing import Any, Dict, Optional, Iterable, List, Tuple
import re
import litellm
import json
import uuid

from dataclasses import dataclass, field, asdict

# ===== Structured Plan Models (Single Source of Truth) =====
class TaskStatus(str, Enum):
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    SKIPPED = "SKIPPED"


def parse_task_status(value: Any) -> TaskStatus:
    """Parse arbitrary status strings to TaskStatus with safe fallbacks.

    Accepts common aliases like "open" -> PENDING, "inprogress" -> IN_PROGRESS, etc.
    """
    text = str(value or "").strip().replace("-", "_").replace(" ", "_").upper()
    if not text:
        return TaskStatus.PENDING

    alias = {
        "OPEN": "PENDING",
        "TODO": "PENDING",
        "INPROGRESS": "IN_PROGRESS",
        "DONE": "COMPLETED",
        "COMPLETE": "COMPLETED",
        "FAIL": "FAILED",
    }
    normalized = alias.get(text, text)
    try:
        return TaskStatus[normalized]
    except KeyError:
        return TaskStatus.PENDING


@dataclass
class TodoItem:
    position: int
    description: str
    tool: str
    parameters: Dict[str, Any]
    status: TaskStatus = TaskStatus.PENDING

    def to_json(self) -> str:
        """Serialize the TodoItem to a JSON string."""
        return json.dumps(self.to_dict(), ensure_ascii=False, indent=2)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the TodoItem to a serializable dict."""
        return {
            "position": self.position,
            "description": self.description,
            "tool": self.tool,
            "parameters": self.parameters,
            "status": self.status.value if isinstance(self.status, TaskStatus) else str(self.status),
        }

@dataclass
class TodoList:
    items: List[TodoItem]
    open_questions: List[str]
    notes: str
    todolist_id: str = field(default_factory=lambda: str(uuid.uuid4()))

    @staticmethod
    def from_json(json_text: Any) -> "TodoList":
        """Create a TodoList from an LLM JSON string/object.

        Accepts either a JSON string or a pre-parsed dict and returns
        a populated TodoList instance with sane fallbacks.
        """
        try:
            data = json.loads(json_text) if isinstance(json_text, str) else (json_text or {})
        except Exception:
            data = {}

        raw_items = data.get("items", []) or []
        items: List[TodoItem] = []
        for index, raw in enumerate(raw_items, start=1):
            try:
                position = int(raw.get("position", index))
            except Exception:
                position = index

            item = TodoItem(
                position=position,
                description=str(raw.get("description", "")).strip(),
                tool=str(raw.get("tool", "")).strip(),
                parameters=raw.get("parameters") or {},
                status=parse_task_status(raw.get("status")),
            )
            items.append(item)

        open_questions = [str(q) for q in (data.get("open_questions", []) or [])]
        notes = str(data.get("notes", ""))
        todolist_id = str(data.get("todolist_id") or str(uuid.uuid4()))

        return TodoList(todolist_id=todolist_id, items=items, open_questions=open_questions, notes=notes)

    def to_dict(self) -> Dict[str, Any]:
        """Convert the TodoList to a serializable dict."""
        # Convert Enum to value for JSON friendliness
        def serialize_item(item: TodoItem) -> Dict[str, Any]:
            return {
                "position": item.position,
                "description": item.description,
                "tool": item.tool,
                "parameters": item.parameters,
                "status": item.status.value if isinstance(item.status, TaskStatus) else str(item.status),
            }

        return {
            "todolist_id": self.todolist_id,
            "items": [serialize_item(i) for i in self.items],
            "open_questions": list(self.open_questions or []),
            "notes": self.notes or "",
        }

    def to_json(self) -> str:
        """Serialize the TodoList to a JSON string."""
        return json.dumps(self.to_dict(), ensure_ascii=False, indent=2)

    def to_markdown(self) -> str:
        """
        Converts a todolist to a markdown string.
        """
        def _status_str(s: Any) -> str:
            # Normalize TaskStatus or string to lowercase text
            if hasattr(s, "value"):
                s = s.value  # Enum-like (e.g., TaskStatus)
            return str(s or "").strip()

        def _is_checked(status_text: str) -> bool:
            st = status_text.lower()
            # Treat these as completed
            return st in {"done", "completed", "success", "succeeded"}

        # Build markdown lines
        lines: List[str] = []
        title = f"Todo List — {self.todolist_id}"
        lines.append(f"# {title}\n")

        if (self.notes or "").strip():
            lines.append("## Notes")
            lines.append(self.notes.strip() + "\n")

        # Items
        lines.append("## Items")
        if not self.items:
            lines.append("_No items yet._\n")
        else:
            # Ensure stable ordering
            items_sorted = sorted(self.items, key=lambda i: (i.position, i.description or ""))
            for item in items_sorted:
                status_text = _status_str(item.status)
                checked = "x" if _is_checked(status_text) else " "
                # Ordered list with GitHub-style checkbox
                lines.append(f"{item.position}. [{checked}] **{item.description or ''}**")
                # Tool and status line
                tool = item.tool or ""
                lines.append(f"   - **Tool:** `{tool}`")
                lines.append(f"   - **Status:** `{status_text or 'unknown'}`")
                # Parameters pretty-printed as JSON
                try:
                    params_json = json.dumps(item.parameters or {}, ensure_ascii=False, indent=2, sort_keys=True)
                except Exception:
                    # Fallback in case parameters aren't JSON-serializable
                    params_json = str(item.parameters)
                lines.append("   - **Parameters:**")
                lines.append("     ```json")
                # Indent each line of the JSON block so it nests nicely under the list item
                for ln in (params_json.splitlines() or ["{}"]):
                    lines.append(f"     {ln}")
                lines.append("     ```\n")

        # Open questions
        lines.append("## Open questions")
        if not self.open_questions:
            lines.append("_None._")
        else:
            for q in self.open_questions:
                lines.append(f"- {q}")

        # Final newline
        lines.append("")
        return "\n".join(lines)


class TodoListManager:
    def __init__(self, base_dir: str = "./checklists"):
        self.base_dir = base_dir


    async def extract_clarification_questions(self, mission: str, tools_desc: str) -> List[Dict[str, Any]]:
        """
        Extracts clarification questions from the mission and tools_desc.

        Args:
            mission: The mission to create the todolist for.
            tools_desc: The description of the tools available.

        Returns:
            A list of clarification questions.
        """
        user_prompt, system_prompt = self.create_clarification_questions_prompts(mission, tools_desc)
        response = await litellm.acompletion(
            model="gpt-4.1",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0  # deterministischer
        )
        raw = response.choices[0].message.content
        try:
            data = json.loads(raw)            
        except json.JSONDecodeError as e:
            # Optional: Fallback/Retry oder klare Fehlermeldung
            raise ValueError(f"Invalid JSON from model: {e}\nRaw: {raw[:500]}")
        return data



    def create_clarification_questions_prompts(self, mission: str, tools_desc: str) -> Tuple[str, str]:
        """
        Creates a prompt for clarification questions (Pre-Clarification).
        Returns (user_prompt, system_prompt).
        """
        system_prompt = f"""
    You are a Clarification-Mining Agent.

    ## Objective
    Find **all** missing required inputs needed to produce an **executable** plan for the mission using the available tools.

    ## Context
    - Mission (user intent and constraints):
    {mission}

    - Available tools (names, descriptions, **parameter schemas including required/optional/default/enums/types**):
    {tools_desc}

    ## Output
    - Return **only** a valid JSON array (no code fences, no commentary).
    - Each element must be:
    - "key": stable, machine-readable snake_case identifier. Prefer **"<tool>.<parameter>"** (e.g., "file_writer.filename"); if tool-agnostic use a clear domain key (e.g., "project_name").
    - "question": **one** short, closed, unambiguous question (one datum per question).

    ## Algorithm (mandatory)
    1) **Parse the mission** to understand the intended outcome and likely steps.
    2) **Enumerate candidate tool invocations** required to achieve the mission (internally; do not output them).
    3) For **each candidate tool**, inspect its **parameter schema**:
    - For every **required** parameter (or optional-without-safe-default) check if its value is **explicitly present** in the mission (exact literal or clearly specified constraint).
    - If not explicitly present, **create a question** for that parameter.
    4) **Respect schema constraints**:
    - Types (string/number/boolean/path/url/email), formats (e.g., kebab-case, ISO-8601), units, min/max.
    - If an enum is specified, ask as a **closed choice** (“Which of: A, B, or C?”).
    - **Do not infer** values unless a **default** is explicitly provided in the schema.
    5) **Merge & deduplicate** questions across tools.
    6) **Confidence gate**:
    - If you are **not 100% certain** every required value is specified, you **must** ask a question for it.
    - If truly nothing is missing, return **[]**.

    ## Strict Rules
    - **Only required info**: Ask only for parameters that are required (or effectively required because no safe default exists).
    - **No tasks, no explanations**: Output questions only.
    - **Closed & precise**:
    - Ask for a single value per question; include necessary format/units/constraints in the question.
    - Avoid ambiguity, multi-part questions, or small talk.
    - **Minimal & deduplicated**: No duplicates; no “nice-to-have” questions.

    ## Heuristic coverage (when relevant tools are present)
    - **File/Path tools**: confirm filename **with extension** and target **directory/path**; avoid ambiguous relative paths.
    - **Code/Project scaffolding**: project name (kebab-case), language/runtime version, package manager.
    - **Git/Repo**: repository name, visibility (public/private), remote provider, default branch, and **auth method/token** if required by schema.
    - **Network/Endpoints**: base URL/host, port, protocol (HTTP/HTTPS).
    - **Auth/Secrets**: explicit key names or secret identifiers if a tool schema requires them.

    ## Examples (illustrative only; do not force)
    [
    {{"key":"file_writer.filename","question":"What should the output file be called (include extension, e.g., report.txt)?"}},
    {{"key":"file_writer.directory","question":"In which directory should the file be created (absolute or project-relative path)?"}},
    {{"key":"git.create_repo.visibility","question":"Should the repository be public or private (choose one: public/private)?"}}
    ]
    """.strip()

        user_prompt = (
            'Provide the missing required information as a JSON array in the form '
            '[{"key":"<tool.parameter|domain_key>", "question":"<closed, precise question>"}]. '
            'If nothing is missing, return [].'
        )

        return user_prompt, system_prompt



    async def create_todolist(self, mission: str, tools_desc: str, answers: Any) -> TodoList:
        """
        Creates a new todolist based on the mission and tools_desc.

        Args:
            mission: The mission to create the todolist for.
            tools_desc: The description of the tools available.

        Returns:
            A new todolist based on the mission and tools_desc.

        Raises:
            ValueError: Invalid JSON from model.

        """
        user_prompt, system_prompt = self.create_final_todolist_prompts(mission, tools_desc, answers)

        response = await litellm.acompletion(
            model="gpt-4.1-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            response_format={"type": "json_object"},
            temperature=0  # deterministischer
        )

        # Sicheres Parsing
        raw = response.choices[0].message.content
        try:
            data = json.loads(raw)
        except json.JSONDecodeError as e:
            # Optional: Fallback/Retry oder klare Fehlermeldung
            raise ValueError(f"Invalid JSON from model: {e}\nRaw: {raw[:500]}")

        todolist = TodoList.from_json(data)
        self.__write_todolist(todolist)
        return todolist

    # def __validate_plan_schema(plan: dict, tool_names: set):
    #     if not isinstance(plan, dict):
    #         raise ValueError("Plan must be a JSON object.")
    #     if "items" not in plan or not isinstance(plan["items"], list):
    #         raise ValueError("Plan.items missing or not a list.")

    #     for step in plan["items"]:
    #         for key in ["id", "description", "tool", "parameters", "depends_on", "status"]:
    #             if key not in step:
    #                 raise ValueError(f"Missing field '{key}' in step.")
    #         if step["tool"] != "none" and step["tool"] not in tool_names:
    #             raise ValueError(f"Unknown tool '{step['tool']}'")
    #         if step["status"] not in {"PENDING", "BLOCKED", "DONE"}:
    #             raise ValueError(f"Invalid status '{step['status']}'")
    #         if not isinstance(step["depends_on"], list):
    #             raise ValueError("depends_on must be a list.")



    async def load_todolist(self, todolist_id: str) -> TodoList:
        """
        Loads a todolist from a file.

        Args:
            todolist_id: The id of the todolist to load.

        Returns:
            A todolist from a file.

        Raises:
            FileNotFoundError: If the todolist file is not found.
        """

        todolist_path = self.get_todolist_path(todolist_id)
        # check if the file exists
        if not todolist_path.exists():
            raise FileNotFoundError(f"Todolist file not found: {todolist_path}")

        # read the file
        with open(todolist_path, "r") as f:
            return TodoList.from_json(f.read())
    

    async def update_todolist(self, todolist: TodoList) -> TodoList:
        """
        Updates a todolist.

        Args:
            todolist: The todolist to update.
        """
        self.__write_todolist(todolist)
        return todolist
        

    async def get_todolist(self, todolist_id: str) -> TodoList:
        """
        Gets a todolist.
        
        Args:
            todolist_id: The id of the todolist to get.
        """
        todolist_path = self.get_todolist_path(todolist_id)
        if not todolist_path.exists():
            raise FileNotFoundError(f"Todolist file not found: {todolist_path}")
        with open(todolist_path, "r") as f:
            return TodoList.from_json(f.read())
        

    async def delete_todolist(self, todolist_id: str) -> bool:
        """
        Deletes a todolist.
        
        Args:
            todolist_id: The id of the todolist to delete.
        """
        todolist_path = self.get_todolist_path(todolist_id)
        if not todolist_path.exists():
            raise FileNotFoundError(f"Todolist file not found: {todolist_path}")
        todolist_path.unlink()
        return True


    def get_todolist_path(self, todolist_id: str) -> Path:
        """
        Gets the path to the todolist file.

        Args:
            todolist_id: The id of the todolist to get the path for.
        """
        return Path(self.base_dir) / f"todolist_{todolist_id}.json"


    def create_final_todolist_prompts(self, mission: str, tools_desc: str, answers: Any) -> Tuple[str, str]:
        """
        Creates a strict prompt for the final TodoList (No-ASK mode).
        Returns (user_prompt, system_prompt).
        """

        structure_block = """
    {
    "items": [
        {
        "id": "t1",
        "description": "Short, precise task description (1–2 sentences)",
        "tool": "tool_name_or_none",
        "parameters": {},
        "depends_on": [],
        "status": "PENDING"
        }
    ],
    "open_questions": [],
    "notes": ""
    }
        """.strip()

        system_prompt = f"""
    You are a planning agent. Your sole task is to convert the mission into a
    strict, executable TODO list. At this point, all required clarifications
    have already been collected — there must be **no questions left**.

    Context:

    - Mission:
    {mission}

    - Clarification Answers (already provided, use them directly):
    {answers}

    - Available tools (names, descriptions, parameter schemas):
    {tools_desc}

    ---

    ## Instructions

    1) OUTPUT FORMAT
    - Return a valid JSON object ONLY — no commentary, no code fences.
    - Match exactly the structure under "Expected JSON structure".

    2) PLAN REQUIREMENTS
    - Produce a minimal, complete, step-by-step plan to fulfill the mission.
    - Each step MUST be atomic (Single Responsibility).
    - Prefer fewer, well-scoped steps over many fuzzy steps.

    3) STEP FIELDS (MUST-HAVES)
    - id: short unique id like "t1", "t2", ...
    - description: 1–2 sentences, outcome-oriented.
    - tool: exact tool name from the provided list, or "none" if no tool is needed.
    - parameters: object with ONLY the required keys for the chosen tool (match the parameters_schema).
    - depends_on: array of step ids that must be completed first (empty if none).
    - status: always "PENDING" initially.

    4) PARAMETERS
    - Use the given Clarification Answers to fill in all required parameter values.
    - **Do not use "ASK_USER"**. Every parameter must be concrete.
    - Do not invent values — use only provided answers or explicit mission context.

    5) DEPENDENCIES
    - Add dependencies to enforce correct execution order.
    - No circular dependencies. All references must exist.

    6) QUALITY CHECKS BEFORE RETURNING
    - JSON is syntactically valid.
    - All tools exist (or "none").
    - parameters strictly conform to the tool’s parameters_schema (no extra keys).
    - All depends_on ids exist; no circular graphs.
    - **open_questions must always be empty**.

    ---

    ## Expected JSON structure
    {structure_block}
        """.strip()

        user_prompt = "Generate the final structured TODO list for the given mission (no questions, no ASK_USER placeholders)."

        return user_prompt, system_prompt


    def __write_todolist(self, todolist: TodoList) -> None:
        """
        Writes a todolist to a file.

        Args:
            todolist: The todolist to write to a file.
        """
        todolist_path = self.get_todolist_path(todolist.todolist_id)
        todolist_path.parent.mkdir(parents=True, exist_ok=True)
        todolist_path.write_text(todolist.to_json(), encoding="utf-8")

# Test function for complex mission requiring at least three tools and three steps
def test_todolist_creation():
    # Example tools description (for LLM context)
    tools_desc = (
        "- file_writer: Write content to a file. parameters_schema: {\"filename\": \"string\", \"content\": \"string\"}\n"
        "- web_search: Search the web for information. parameters_schema: {\"query\": \"string\"}\n"
        "- email_sender: Send an email. parameters_schema: {\"recipient\": \"string\", \"subject\": \"string\", \"body\": \"string\"}"
    )
    # Complex mission requiring all three tools
    mission = (
        "Research the latest advancements in AI, summarize the findings in a report.txt file, "
        "and email the report to the project manager at manager@example.com."
    )
    mission_context = {
        "user_request": "Please help me get an overview of the newest AI developments and send a summary to my manager.",
        "tools_desc": tools_desc,
        "context": "You have access to file_writer, web_search, and email_sender tools."
    }
    manager = TodoListManager()
    # Assuming create_todolist is async, but for test, we call it synchronously for illustration
    # In real test, use asyncio.run or pytest-asyncio
    import asyncio
    todolist = asyncio.run(manager.create_todolist(mission=mission, mission_context=mission_context))

    print("Todolist created:")
    print(todolist.to_json())
    pass





if __name__ == "__main__":
    test_todolist_creation()










// Relative Path: tools\ask_user_tool.py
# ============================================
# ASK USER TOOL (first-class)
# ============================================
from typing import Any, Dict, List
from capstone.agent_v2.tool import Tool


class AskUserTool(Tool):
    """Model-invoked prompt to request missing info from a human."""

    @property
    def name(self) -> str:
        return "ask_user"

    @property
    def description(self) -> str:
        return "Ask the user for missing info to proceed. Returns a structured question payload."

    @property
    def parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "question": {"type": "string", "description": "One clear question"},
                "missing": {"type": "array", "items": {"type": "string"}},
            },
            "required": ["question"],
        }

    async def execute(self, question: str, missing: List[str] = None, **kwargs) -> Dict[str, Any]:
        return {"success": True, "question": question, "missing": missing or []}




// Relative Path: tools\code_tool.py
# ============================================
# PYTHON CODE EXECUTION TOOL
# ============================================
from typing import Any, Dict
import os
from pathlib import Path
from capstone.agent_v2.tool import Tool


class PythonTool(Tool):
    """Execute Python code for complex operations"""
    
    @property
    def name(self) -> str:
        return "python"
    
    @property
    def description(self) -> str:
        return "Execute Python code for complex logic, data processing, and custom operations. Code should set 'result' variable."
    
    async def execute(self, code: str, context: Dict[str, Any] = None, cwd: str = None, **kwargs) -> Dict[str, Any]:
        """
        Execute Python code in controlled namespace.
        Code has access to standard libraries and must set 'result' variable.
        """
        
        # Create safe namespace
        safe_namespace = {
            "__builtins__": {
                # Basic functions
                "print": print, "len": len, "range": range, "enumerate": enumerate,
                "str": str, "int": int, "float": float, "bool": bool,
                "list": list, "dict": dict, "set": set, "tuple": tuple,
                "sum": sum, "min": min, "max": max, "abs": abs,
                "round": round, "sorted": sorted, "reversed": reversed,
                "zip": zip, "map": map, "filter": filter,
                "any": any, "all": all, "isinstance": isinstance,
                "open": open,  # Use with caution
                "__import__": __import__,
            },
            "context": context or {},
        }
        
        # Import common libraries
        import_code = """
import os, sys, json, re, pathlib, shutil
import subprocess, datetime, time, random
import base64, hashlib, tempfile, csv
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
"""
        
        # Optionally change working directory
        original_cwd = os.getcwd()
        cwd_path = None
        if cwd is not None:
            if not isinstance(cwd, str):
                return {"success": False, "error": "cwd must be a string path"}
            sanitized = cwd.strip()
            if (sanitized.startswith('"') and sanitized.endswith('"')) or (sanitized.startswith("'") and sanitized.endswith("'")):
                sanitized = sanitized[1:-1]
            sanitized = os.path.expandvars(os.path.expanduser(sanitized))
            if os.name == "nt":
                sanitized = sanitized.replace("/", "\\")
            p = Path(sanitized)
            if not p.exists() or not p.is_dir():
                return {"success": False, "error": f"cwd does not exist or is not a directory: {sanitized}"}
            cwd_path = str(p)

        try:
            if cwd_path:
                os.chdir(cwd_path)
            # Execute imports
            exec(import_code, safe_namespace)
            
            # Execute user code
            exec(code, safe_namespace)
            
            # Extract result
            result_value = safe_namespace.get('result', None)
            
            # Get all user-defined variables
            user_vars = {
                k: v for k, v in safe_namespace.items()
                if not k.startswith('_') 
                and k not in ['os', 'sys', 'json', 're', 'pathlib', 'shutil',
                             'subprocess', 'datetime', 'time', 'random',
                             'base64', 'hashlib', 'tempfile', 'csv', 'Path',
                             'timedelta', 'Dict', 'List', 'Any', 'Optional', 'context']
            }
            
            return {
                "success": True,
                "result": result_value,
                "variables": user_vars,
                "context_updated": safe_namespace.get('context', {})
            }
            
        except Exception as e:
            import traceback
            return {
                "success": False,
                "error": str(e),
                "type": type(e).__name__,
                "traceback": traceback.format_exc(),
                "cwd": cwd_path or original_cwd,
            }
        finally:
            try:
                os.chdir(original_cwd)
            except Exception:
                pass




// Relative Path: tools\file_tool.py
# ============================================
# FILE SYSTEM TOOLS
# ============================================
from pathlib import Path
from typing import Any, Dict
from capstone.agent_v2.tool import Tool


class FileReadTool(Tool):
    """Safe file reading with size limits"""
    
    @property
    def name(self) -> str:
        return "file_read"
    
    @property
    def description(self) -> str:
        return "Read file contents safely with size limits and encoding detection"
    
    async def execute(self, path: str, encoding: str = "utf-8", max_size_mb: int = 10, **kwargs) -> Dict[str, Any]:
        """
        Read file contents safely with size limits and encoding detection

        Args:
            path: The path to the file to read
            encoding: The encoding of the file
            max_size_mb: The maximum size of the file in MB

        Returns:
            A dictionary with the following keys:
            - success: True if the file was read successfully, False otherwise
            - content: The contents of the file
            - size: The size of the file in bytes
            - path: The path to the file
        """
        try:
            file_path = Path(path)
            
            if not file_path.exists():
                return {"success": False, "error": f"File not found: {path}"}
            
            file_size_mb = file_path.stat().st_size / (1024 * 1024)
            if file_size_mb > max_size_mb:
                return {"success": False, "error": f"File too large: {file_size_mb:.2f}MB > {max_size_mb}MB"}
            
            content = file_path.read_text(encoding=encoding)
            return {
                "success": True,
                "content": content,
                "size": len(content),
                "path": str(file_path.absolute())
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

class FileWriteTool(Tool):
    """Safe file writing with backup option"""
    
    @property
    def name(self) -> str:
        return "file_write"
    
    @property
    def description(self) -> str:
        return "Write content to file with backup and safety checks"
    
    async def execute(self, path: str, content: str, backup: bool = True, **kwargs) -> Dict[str, Any]:
        """
        Write content to file with backup and safety checks

        Args:
            path: The path to the file to write
            content: The content to write to the file
            backup: Whether to backup the existing file

        Returns:
            A dictionary with the following keys:
            - success: True if the file was written successfully, False otherwise
            - path: The path to the file
            - size: The size of the file in bytes
            - backed_up: Whether the existing file was backed up
            - error: The error message if the file was not written successfully
        """
        try:
            file_path = Path(path)
            
            # Backup existing file
            if backup and file_path.exists():
                backup_path = file_path.with_suffix(file_path.suffix + ".bak")
                backup_path.write_text(file_path.read_text(), encoding='utf-8')
            
            # Create parent directories
            file_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write content
            file_path.write_text(content, encoding='utf-8')
            
            return {
                "success": True,
                "path": str(file_path.absolute()),
                "size": len(content),
                "backed_up": backup and file_path.exists()
            }
        except Exception as e:
            return {"success": False, "error": str(e)}




// Relative Path: tools\git_tool.py
# ============================================
# GIT TOOL
# ============================================

import json
import os
from pathlib import Path
import subprocess
from typing import Any, Optional, Dict, Tuple
import urllib

from capstone.agent_v2.tool import Tool


class GitTool(Tool):
    """Comprehensive Git operations"""
    
    @property
    def name(self) -> str:
        return "git"
    
    @property
    def description(self) -> str:
        return "Execute git operations (init, add, commit, push, status, clone, etc.)"
    
    @property
    def parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "operation": {
                    "type": "string",
                    "enum": ["init", "add", "commit", "push", "status", "clone", "remote"],
                    "description": "Git operation to perform"
                },
                "repo_path": {
                    "type": "string",
                    "description": "Repository path (default: current directory)"
                },
                "message": {
                    "type": "string",
                    "description": "Commit message (for commit operation)"
                },
                "files": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Files to add (for add operation)"
                },
                "url": {
                    "type": "string",
                    "description": "Remote URL (for remote/clone operations)"
                },
                "branch": {
                    "type": "string",
                    "description": "Branch name"
                }
            },
            "required": ["operation"]
        }
    
    async def execute(self, operation: str, repo_path: str = ".", **kwargs) -> Dict[str, Any]:
        try:
            repo_path = Path(repo_path)
            
            # Build command based on operation
            if operation == "init":
                cmd = ["git", "init", "-b", kwargs.get("branch", "main")]
            elif operation == "add":
                files = kwargs.get("files", ["."])
                cmd = ["git", "add"] + files
            elif operation == "commit":
                message = kwargs.get("message", "Commit via HybridAgent")
                cmd = ["git", "commit", "-m", message]
            elif operation == "push":
                remote = kwargs.get("remote", "origin")
                branch = kwargs.get("branch", "main")
                cmd = ["git", "push", "-u", remote, branch]
            elif operation == "status":
                cmd = ["git", "status", "--short"]
            elif operation == "clone":
                url = kwargs.get("url")
                if not url:
                    return {"success": False, "error": "URL required for clone"}
                cmd = ["git", "clone", url, str(repo_path)]
            elif operation == "remote":
                action = kwargs.get("action", "add")
                if action == "add":
                    cmd = ["git", "remote", "add", kwargs.get("name", "origin"), kwargs["url"]]
                else:
                    cmd = ["git", "remote", "-v"]
            else:
                return {"success": False, "error": f"Unknown operation: {operation}"}
            
            # Execute command
            result = subprocess.run(
                cmd,
                cwd=repo_path if operation != "clone" else ".",
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return {
                "success": result.returncode == 0,
                "output": result.stdout,
                "error": result.stderr if result.returncode != 0 else None,
                "command": " ".join(cmd)
            }
            
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Command timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}


# ============================================
# GITHUB TOOL
# ============================================

class GitHubTool(Tool):
    """GitHub operations using GitHub REST API (requires GITHUB_TOKEN)"""
    
    @property
    def name(self) -> str:
        return "github"
    
    @property
    def description(self) -> str:
        return "GitHub operations (create/list/delete repos) using REST API. Requires GITHUB_TOKEN."
    
    @property
    def parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "action": {
                    "type": "string",
                    "enum": ["create_repo", "list_repos", "delete_repo"],
                    "description": "GitHub action to perform"
                },
                "name": {
                    "type": "string",
                    "description": "Repository name"
                },
                "private": {
                    "type": "boolean",
                    "description": "Make repository private"
                },
                "description": {
                    "type": "string",
                    "description": "Repository description"
                }
            },
            "required": ["action"]
        }
    
    async def execute(self, action: str, **kwargs) -> Dict[str, Any]:
        try:
            token = os.getenv("GITHUB_TOKEN") or os.getenv("GH_TOKEN")
            if not token:
                return {"success": False, "error": "GITHUB_TOKEN environment variable is not set"}
            
            api_base = "https://api.github.com"
            
            def request(method: str, url: str, body: Optional[Dict[str, Any]] = None) -> Tuple[int, str]:
                headers = {
                    "Accept": "application/vnd.github+json",
                    "Authorization": f"Bearer {token}",
                    "X-GitHub-Api-Version": "2022-11-28",
                    "User-Agent": "HybridAgent"
                }
                data_bytes = None
                if body is not None:
                    data_bytes = json.dumps(body).encode("utf-8")
                    headers["Content-Type"] = "application/json"
                req = urllib.request.Request(url, data=data_bytes, headers=headers, method=method)
                try:
                    with urllib.request.urlopen(req, timeout=30) as resp:
                        return resp.getcode(), resp.read().decode("utf-8")
                except urllib.error.HTTPError as e:
                    try:
                        detail = e.read().decode("utf-8")
                    except Exception:
                        detail = str(e)
                    return e.code, detail
                except urllib.error.URLError as e:
                    return 0, f"URLError: {e.reason}"
            
            if action == "create_repo":
                repo_name = kwargs.get("name")
                if not repo_name:
                    return {"success": False, "error": "Repository name required"}
                body = {
                    "name": repo_name,
                    "private": bool(kwargs.get("private", False)),
                    "description": kwargs.get("description") or ""
                }
                status, text = request("POST", f"{api_base}/user/repos", body)
                ok = status in (200, 201)
                payload = {}
                try:
                    payload = json.loads(text) if text else {}
                except Exception:
                    payload = {"raw": text}
                error_msg = None
                if not ok:
                    # Surface useful validation errors (422) or auth issues
                    base_msg = payload.get("message") if isinstance(payload, dict) else None
                    errors = payload.get("errors") if isinstance(payload, dict) else None
                    if status == 422 and errors:
                        error_msg = f"Validation failed: {errors}"
                    elif status in (401, 403):
                        error_msg = base_msg or "Authentication/authorization failed. Check GITHUB_TOKEN scopes."
                    else:
                        error_msg = base_msg or text or f"HTTP {status}"
                return {
                    "success": ok,
                    "repo_name": repo_name,
                    "response_status": status,
                    "repo_full_name": payload.get("full_name") if isinstance(payload, dict) else None,
                    "repo_html_url": payload.get("html_url") if isinstance(payload, dict) else None,
                    "error": error_msg,
                }
            
            elif action == "list_repos":
                status, text = request("GET", f"{api_base}/user/repos?per_page=20")
                ok = status == 200
                repos = []
                try:
                    data = json.loads(text) if text else []
                    repos = [item.get("full_name") for item in data if isinstance(item, dict)]
                except Exception:
                    repos = []
                return {
                    "success": ok,
                    "repos": repos,
                    "response_status": status,
                    "error": None if ok else text
                }
            
            elif action == "delete_repo":
                full_name = kwargs.get("name")
                if not full_name or "/" not in full_name:
                    return {"success": False, "error": "Repository name must be in 'owner/repo' format"}
                status, text = request("DELETE", f"{api_base}/repos/{full_name}")
                ok = status in (200, 202, 204)
                return {
                    "success": ok,
                    "repo_name": full_name,
                    "response_status": status,
                    "error": None if ok else text
                }
            
            else:
                return {"success": False, "error": f"Unknown action: {action}"}
        except urllib.error.HTTPError as e:
            try:
                detail = e.read().decode("utf-8")
            except Exception:
                detail = str(e)
            return {"success": False, "error": f"HTTPError {e.code}: {detail}"}
        except urllib.error.URLError as e:
            return {"success": False, "error": f"URLError: {e.reason}"}
        except Exception as e:
            return {"success": False, "error": str(e)}




// Relative Path: tools\shell_tool.py
# ============================================
# SHELL TOOL
# ============================================

import asyncio
import os
import shutil
from pathlib import Path
from typing import Any, Dict
from capstone.agent_v2.tool import Tool


class ShellTool(Tool):
    """Execute shell commands with safety limits"""
    
    @property
    def name(self) -> str:
        return "shell"
    
    @property
    def description(self) -> str:
        return "Execute shell commands with timeout and safety limits"
    
    async def execute(self, command: str, timeout: int = 30, cwd: str = None, **kwargs) -> Dict[str, Any]:
        try:
            # Safety check - block dangerous commands
            dangerous_patterns = [
                "rm -rf /", "rm -rf /*", 
                "dd if=/dev/zero", "dd if=/dev/random",
                "format c:", "del /f /s /q",
                ":(){ :|:& };:",  # Fork bomb
                "> /dev/sda",
                "mkfs.",
            ]
            
            if any(pattern in command.lower() for pattern in dangerous_patterns):
                return {"success": False, "error": "Command blocked for safety reasons"}
            
            # Execute command
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=timeout
                )

                success = process.returncode == 0
                stdout_text = stdout.decode() if stdout else ""
                stderr_text = stderr.decode() if stderr else ""

                resp = {
                    "success": success,
                    "stdout": stdout_text,
                    "stderr": stderr_text,
                    "returncode": process.returncode,
                    "command": command
                }
                if not success:
                    resp["error"] = stderr_text or f"Command failed with code {process.returncode}"
                return resp
            except asyncio.TimeoutError:
                process.kill()
                return {"success": False, "error": f"Command timed out after {timeout}s"}
                
        except Exception as e:
            return {"success": False, "error": str(e)}

# ============================================
# Power Shell Tool
# ============================================

class PowerShellTool(Tool):
    """Execute PowerShell commands with safety limits"""
    
    @property
    def name(self) -> str:
        return "powershell"
    
    @property
    def description(self) -> str:
        return "Execute PowerShell commands with timeout and safety limits"

    async def execute(self, command: str, timeout: int = 30, cwd: str = None, **kwargs) -> Dict[str, Any]:

        # Safety check - block dangerous powershell commands (case-insensitive)
        dangerous_patterns = [
            "Remove-Item -Path * -Force",
            "Remove-Item -Path * -Recurse",
            "Remove-Item -Path * -Recurse -Force",
            "Remove-Item -Path * -Recurse -Force",
        ]
        lower_cmd = command.lower()
        lower_patterns = [p.lower() for p in dangerous_patterns]
        if any(pattern in lower_cmd for pattern in lower_patterns):
            return {"success": False, "error": "Command blocked for safety reasons"}

        # Resolve PowerShell executable
        shell_exe = shutil.which("pwsh") or shutil.which("powershell")
        if not shell_exe:
            return {"success": False, "error": "No PowerShell executable found (pwsh/powershell)"}

        # Coerce command to string (LLM may send non-string by mistake)
        if not isinstance(command, str):
            try:
                command = str(command)
            except Exception:
                return {"success": False, "error": "Invalid command type; expected string"}

        # Sanitize and validate cwd
        cwd_path: str | None = None
        if cwd is not None:
            if not isinstance(cwd, str):
                return {"success": False, "error": "cwd must be a string path"}
            sanitized = cwd.strip()
            if (sanitized.startswith('"') and sanitized.endswith('"')) or (sanitized.startswith("'") and sanitized.endswith("'")):
                sanitized = sanitized[1:-1]
            # Expand env vars and user (~)
            sanitized = os.path.expandvars(os.path.expanduser(sanitized))
            # Normalize separators for Windows
            if os.name == "nt":
                sanitized = sanitized.replace("/", "\\")
            if sanitized == "":
                cwd_path = None
            else:
                p = Path(sanitized)
                if not p.exists() or not p.is_dir():
                    return {"success": False, "error": f"cwd does not exist or is not a directory: {sanitized}"}
                cwd_path = str(p)

        try:
            # Execute command explicitly via PowerShell
            process = await asyncio.create_subprocess_exec(
                shell_exe,
                "-NoProfile",
                "-NonInteractive",
                "-ExecutionPolicy",
                "Bypass",
                "-Command",
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd_path
            )
        except Exception as e:
            return {"success": False, "error": str(e)}
            
        try:
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )
        except asyncio.TimeoutError:
            try:
                process.kill()
            except Exception:
                pass
            return {
                "success": False,
                "error": f"Command timed out after {timeout}s",
                "command": command,
                "cwd": cwd_path,
                "returncode": None,
            }
        except asyncio.CancelledError:
            try:
                process.kill()
            except Exception:
                pass
            return {
                "success": False,
                "error": f"Command cancelled after {timeout}s",
                "command": command,
                "cwd": cwd_path,
                "returncode": None,
            }
        except Exception as e:
            try:
                process.kill()
            except Exception:
                pass
            return {"success": False, "error": str(e), "command": command, "cwd": cwd_path}
            
        success = process.returncode == 0
        stdout_text = stdout.decode() if stdout else ""
        stderr_text = stderr.decode() if stderr else ""

        resp = {
            "success": success,
            "stdout": stdout_text,
            "stderr": stderr_text,
            "returncode": process.returncode,
            "command": command
        }
        if not success:
            resp["error"] = stderr_text or f"Command failed with code {process.returncode}"
        return resp





// Relative Path: tools\web_tool.py
# ============================================
# WEB TOOLS
# ============================================

import asyncio
import re
from typing import Any, Dict
import aiohttp
from capstone.agent_v2.tool import Tool


class WebSearchTool(Tool):
    """Web search using DuckDuckGo (no API key required)"""
    
    @property
    def name(self) -> str:
        return "web_search"
    
    @property
    def description(self) -> str:
        return "Search the web using DuckDuckGo"
    
    async def execute(self, query: str, num_results: int = 5, **kwargs) -> Dict[str, Any]:
        if not aiohttp:
            return {"success": False, "error": "aiohttp not installed"}
        
        try:
            async with aiohttp.ClientSession() as session:
                params = {
                    "q": query,
                    "format": "json",
                    "no_html": "1",
                    "skip_disambig": "1"
                }
                
                async with session.get(
                    "https://api.duckduckgo.com/",
                    params=params,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    # DuckDuckGo may return a non-standard JSON Content-Type (e.g., application/x-javascript)
                    # Allow json() to parse regardless of Content-Type to avoid ContentTypeError.
                    data = await response.json(content_type=None)
                    
                    results = []
                    
                    # Extract abstract if available
                    if data.get("Abstract"):
                        results.append({
                            "title": data.get("Heading", ""),
                            "snippet": data["Abstract"],
                            "url": data.get("AbstractURL", "")
                        })
                    
                    # Extract related topics
                    for topic in data.get("RelatedTopics", [])[:num_results]:
                        if isinstance(topic, dict) and "Text" in topic:
                            results.append({
                                "title": topic.get("Text", "").split(" - ")[0][:50],
                                "snippet": topic.get("Text", ""),
                                "url": topic.get("FirstURL", "")
                            })
                    
                    return {
                        "success": True,
                        "query": query,
                        "results": results[:num_results],
                        "count": len(results)
                    }
                    
        except Exception as e:
            return {"success": False, "error": str(e)}
            

class WebFetchTool(Tool):
    """Fetch content from URLs"""
    
    @property
    def name(self) -> str:
        return "web_fetch"
    
    @property
    def description(self) -> str:
        return "Fetch and extract content from a URL"
    
    async def execute(self, url: str, **kwargs) -> Dict[str, Any]:
        if not aiohttp:
            return {"success": False, "error": "aiohttp not installed"}
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url,
                    timeout=aiohttp.ClientTimeout(total=15)
                ) as response:
                    content = await response.text()
                    
                    # Simple HTML extraction
                    if "text/html" in response.headers.get("Content-Type", ""):
                        # Remove HTML tags (basic)
                        text = re.sub('<script[^>]*>.*?</script>', '', content, flags=re.DOTALL)
                        text = re.sub('<style[^>]*>.*?</style>', '', content, flags=re.DOTALL)
                        text = re.sub('<[^>]+>', '', text)
                        text = ' '.join(text.split())[:5000]  # Limit size
                    else:
                        text = content[:5000]
                    
                    return {
                        "success": True,
                        "url": url,
                        "status": response.status,
                        "content": text,
                        "content_type": response.headers.get("Content-Type", ""),
                        "length": len(content)
                    }
                    
        except asyncio.TimeoutError:
            return {"success": False, "error": "Request timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}



// Relative Path: agent.py
# An Agent class

from dataclasses import field
from enum import Enum
import json
from pathlib import Path
import sys
from typing import Any, AsyncIterator, Dict, List, Optional
from attr import asdict, dataclass
import litellm

from capstone.agent_v2.planning.todolist import TaskStatus, TodoItem, TodoList, TodoListManager
from capstone.agent_v2.statemanager import StateManager
from capstone.agent_v2.tool import Tool
from capstone.agent_v2.tools.code_tool import PythonTool
from capstone.agent_v2.tools.file_tool import FileReadTool, FileWriteTool
from capstone.agent_v2.tools.git_tool import GitHubTool, GitTool
from capstone.agent_v2.tools.shell_tool import PowerShellTool
from capstone.agent_v2.tools.web_tool import WebFetchTool, WebSearchTool

GENERIC_SYSTEM_PROMPT = """
You are a ReAct-style execution agent.

## Core Principles
- **Plan First**: Always build or refine a Todo List before executing. Plans must be minimal, deterministic, and single-responsibility (each step has one clear outcome).
- **Clarify Early**: If any required parameter is unknown, mark it as "ASK_USER" and add a precise clarification question to open_questions. Do not guess.
- **Determinism & Minimalism**: Prefer fewer, well-scoped steps over many fuzzy ones. Outputs must be concise, structured, and directly actionable. No filler text.
- **Tool Preference**: Use available tools whenever possible. Only ask the user when essential data is missing. Never hallucinate tools.
- **State Updates**: After every tool call or user clarification, update state (Todo List, step status, answers). Avoid infinite loops.
- **Stop Condition**: End execution when the mission’s acceptance criteria are met or all Todo steps are completed.

## Decision Policy
- Prefer tools > ask_user > stop.
- Never assume implicit values—ask explicitly if uncertain.
- Re-plan only if a blocker is discovered (missing parameter, failed tool, new mission context).

## Output & Communication Style
- Responses must be short, structured, and CLI-friendly.
- For planning: return strict JSON matching the required schema.
- For execution: emit clear status lines or structured events (thought, action, result, ask_user).
- For ask_user: provide exactly one direct, actionable question.

## Roles
- **Planner**: Convert the mission into a Todo List (JSON). Insert "ASK_USER" placeholders where input is required. Ensure dependencies are correct and non-circular.
- **Executor**: Process each Todo step in order. For each step: generate a thought, decide one next action, execute, record observation.
- **Clarifier**: When encountering ASK_USER, pause execution and request the answer in a single, well-phrased question. Resume once the answer is given.
- **Finisher**: Stop once all Todo items are resolved or the mission goal is clearly achieved. Emit a "complete" action with a final status message.

## Constraints
- Always produce valid JSON when asked.
- Do not output code fences, extra commentary, or natural-language paragraphs unless explicitly required.
- Keep rationales ≤2 sentences.
- Be strict: only valid action types are {tool_call, ask_user, complete, update_todolist, error_recovery}.
"""

# Ich brauche noch eine Messsage History Klasse die die Kommunikation zwischen dem Agent und dem User speichert
# Die sollte ungefähr so aussehen:
# messages=[
#  {"role": "system", "content": system_prompt},
#  {"role": "user", "content": user_prompt}
#  {"role": "assistant", "content": assistant_prompt}
#  {"role": "user", "content": user_prompt}
#  {"role": "assistant", "content": assistant_prompt}
#  {"role": "user", "content": user_prompt}
# ],
# Der System Prompt ist immer der erste Eintrag in der Liste. Ich will aber nicht, dass ich dem LLM den
# gesamten Chat History sende. Ich will nur den System Prompt und die letzten n messages (User und Assistant) senden.
# Das n sollte einstellbar sein!
class MessageHistory:
    def __init__(self, system_prompt: str):
        # Store system prompt as the first message entry
        self.system_prompt = {"role": "system", "content": system_prompt}
        self.messages = [self.system_prompt]

    def add_message(self, message: str, role: str) -> None:
        """
        Adds a message to the message history.

        Args:
            message: The message to add.
            role: The role of the message.
        """
        self.messages.append({"role": role, "content": message})

    def get_last_n_messages(self, n: int) -> List[Dict[str, Any]]:
        """
        Gets the last n message pairs (user and assistant) in chronological order,
        always including the system prompt as the first message. If there is an
        incomplete trailing message (no pair), it is ignored.

        Args:
            n: The number of message pairs to get.
        """
        if n <= 0:
            return [self.system_prompt]

        # Exclude the system prompt from pairing logic
        body = self.messages[1:]
        num_pairs = len(body) // 2

        if num_pairs == 0:
            return [self.system_prompt]

        if n >= num_pairs:
            # Return all complete pairs
            return [self.system_prompt] + body[: num_pairs * 2]

        # Return only the last n pairs, preserving chronological order
        start_index = len(body) - (n * 2)
        return [self.system_prompt] + body[start_index:]

    def replace_system_prompt(self, system_prompt: str) -> None:
        """
        Replaces the system prompt with the new system prompt.

        Args:
            system_prompt: The new system prompt.
        """
        self.system_prompt = {"role": "system", "content": system_prompt}
        self.messages[0] = self.system_prompt

    def __str__(self) -> str:
        return json.dumps(self.messages, ensure_ascii=False, indent=2)


class ActionType(Enum):
    TOOL = "tool_call"
    ASK  = "ask_user"
    DONE = "complete"
    PLAN = "update_todolist"
    ERR  = "error_recovery"

@dataclass
class ThoughtAction:
    type: ActionType
    tool: Optional[str] = None
    input: Dict[str, Any] = field(default_factory=dict)
    question: Optional[str] = None   # nur bei ask_user
    message: Optional[str] = None    # nur bei complete

    @staticmethod
    def from_json(json_str: str) -> "ThoughtAction":
        """
        Creates a ThoughtAction object from a JSON string.
        """
        # Accept both JSON string and already-parsed dict
        if isinstance(json_str, (str, bytes, bytearray)):
            data = json.loads(json_str)
        elif isinstance(json_str, dict):
            data = json_str
        else:
            raise TypeError("ThoughtAction.from_json expects str|bytes|bytearray|dict")

        action_type_value = data.get("type")
        action_type = action_type_value if isinstance(action_type_value, ActionType) else ActionType(action_type_value)

        return ThoughtAction(
            type=action_type,
            tool=data.get("tool"),
            input=data.get("input", {}),
            question=data.get("question"),
            message=data.get("message"))

@dataclass
class Thought:
    next_step_ref: int
    rationale: str                   # kurz, max. 2 Sätze
    action: ThoughtAction
    expected_outcome: str

    @staticmethod
    def from_json(json_str: str) -> "Thought":
        """
        Creates a Thought object from a JSON string.
        """
        # Accept both JSON string and already-parsed dict
        if isinstance(json_str, (str, bytes, bytearray)):
            data = json.loads(json_str)
        elif isinstance(json_str, dict):
            data = json_str
        else:
            raise TypeError("Thought.from_json expects str|bytes|bytearray|dict")
        return Thought(
            next_step_ref=data["next_step_ref"],
            rationale=data["rationale"],
            action=ThoughtAction.from_json(data["action"]),
            expected_outcome=data["expected_outcome"])

# create an Action class which is a dataclass with the following fields:
# - type: ActionType
# - tool: Optional[str]
# - input: Dict[str, Any]
# - question: Optional[str]
# - message: Optional[str]
@dataclass
class Action:
    type: ActionType
    tool: Optional[str]
    input: Dict[str, Any]

    @staticmethod
    def from_json(json_str: str) -> "Action":
        """
        Creates an Action object from a JSON string.
        """
        data = json.loads(json_str)
        return Action(
            type=ActionType(data["type"]),
            tool=data["tool"],
            input=data["input"])


@dataclass
class AgentEventType(Enum):
    THOUGHT = "thought"
    ACTION = "action"
    TOOL_STARTED = "tool_started"
    TOOL_RESULT = "tool_result"
    ASK_USER = "ask_user"
    STATE_UPDATED = "state_updated"
    COMPLETE = "complete"
    ERROR = "error"


@dataclass
class AgentEvent:
    type: AgentEventType
    data: Dict[str, Any]


@dataclass
class Observation:
    success: bool
    error: Optional[str] = None
    data: Dict[str, Any] = None
    requires_user: bool = False


def build_system_prompt(system_prompt: str, mission: str, todo_list: Optional[str] = "") -> str:
    """
    Build the system prompt from base, mission, and todo list sections.

    Args:
        system_prompt (str): The static base instructions (timeless context).
        mission (str): The agent's mission or current objective.
        todo_list (str, optional): Current todo list, may be empty. Defaults to "".

    Returns:
        str: Final system prompt ready for use.
    """
    prompt = f"""<Base>
{system_prompt.strip()}
</Base>

<Mission>
{mission.strip() if mission else ""}
</Mission>

<TODOList>
{todo_list.strip() if todo_list else ""}
</TODOList>"""
    return prompt



class Agent:
    def __init__(self, 
        name: str, 
        description: str, 
        system_prompt: Optional[str],
        mission: Optional[str],
        tools: List[Tool],
        todo_list_manager: TodoListManager,
        state_manager: StateManager,
        llm):
        """
        Initializes the Agent with the given name, description, system prompt, mission, tools, and planner.
        Args:
            name: The name of the agent.
            description: The description of the agent.
            system_prompt: The system prompt for the agent. This the generic part of the agent's system prompt.
            mission: The mission for the agent. This is a collection of tasks that the agent needs to complete.
            tools: The tools for the agent. This is a collection of tools that the agent can use to complete the tasks.
            planner: The planner for the agent. This is the planner that the agent uses to plan the tasks.
            state_manager: The state manager for the agent. This is the state manager that the agent uses to save the state of the agent.
        """

        self.name = name
        self.description = description
        self.system_prompt = system_prompt
        self.mission = mission
        self.tools = tools
        self.tools_description = self._get_tools_description()
        self.tools_schema = self._get_tools_schema()
        self.todo_list_manager = todo_list_manager
        self.state_manager = state_manager
        self.state = None
        self.message_history = MessageHistory(build_system_prompt(system_prompt, mission, self.tools_description))


    async def execute(self, user_message: str, session_id: str) -> AsyncIterator[AgentEvent]:
        """
        Executes the agent with the given user message using a Pre-Clarification pass:
        1) Collect & resolve all missing required info (closed-form questions).
        2) Create a final TodoList (no ASK_USER, no open_questions).
        3) Run the ReAct loop to complete the tasks.

        Args:
            user_message: The user message to execute the agent.
            session_id: The session id to execute the agent.

        Returns:
            An async iterator of AgentEvent.
        """
        # --- 0) Load state -------------------------------------------------------
        self.state = await self.state_manager.load_state(session_id)

        if self.mission is None:
            self.mission = user_message

        # If we were awaiting an answer, consume it immediately
        if self.state.get("pending_question"):
            answer = user_message.strip()
            pending_question = self.state.pop("pending_question")
            # store the answer by stable key
            answers = self.state.setdefault("answers", {})
            answers[pending_question["answer_key"]] = answer
            await self.state_manager.save_state(session_id, self.state)
            yield AgentEvent(type=AgentEventType.STATE_UPDATED, data={"answers": answers})

            # Nach einer beantworteten Frage: user_message nicht als neues inhaltliches Prompt verwenden
            # (wir bleiben im Clarification-Flow). Kein return hier: wir laufen weiter und prüfen,
            # ob noch weitere Fragen offen sind / ob wir planen können.

        # --- 1) Update message history & mission --------------------------------
        self.message_history.add_message(user_message, "user")
        self.state["message_history"] = self.message_history.messages
        self.state["last_user_message"] = user_message
        self.state["mission"] = self.mission
        answers = self.state.setdefault("answers", {})
        await self.state_manager.save_state(session_id, self.state)

        # --- 2) Pre-Clarification Gate (nur wenn noch kein finaler Plan existiert) ---
        todolist = None
        if not self.state.get("todolist_id"):
            # 2.a) Fragen extrahieren, falls noch nicht geschehen
            if "clar_questions" not in self.state:
                clar_qs = await self.todo_list_manager.extract_clarification_questions(
                    mission=self.mission,
                    tools_desc=self.tools_description
                )
                self.state["clar_questions"] = clar_qs or []
                await self.state_manager.save_state(session_id, self.state)

            # 2.b) Unbeantwortete Frage suchen (per stable key)
            unanswered = next(
                (q for q in self.state["clar_questions"] if q.get("key") not in answers),
                None
            )
            if unanswered:
                # ask user now; pause execution until answered
                self.state["pending_question"] = {
                    "answer_key": unanswered["key"],
                    "question": unanswered["question"]
                }
                await self.state_manager.save_state(session_id, self.state)
                yield AgentEvent(type=AgentEventType.ASK_USER, data={"question": unanswered["question"]})
                return

            # 2.c) Alle Fragen beantwortet -> finalen Plan erstellen (No-ASK mode)
            todolist = await self.todo_list_manager.create_todolist(
                mission=self.mission,
                tools_desc=self.tools_description,
                answers=answers
            )

            # 2.d) Harte Guards: keine open_questions, keine ASK_USER-Platzhalter
            if getattr(todolist, "open_questions", None):
                raise ValueError("Final plan contains open_questions, expected none in No-ASK mode.")

            for item in todolist.items:
                if getattr(item, "parameters", None):
                    for v in item.parameters.values():
                        if isinstance(v, str) and v.strip().upper() == "ASK_USER":
                            raise ValueError("Final plan contains ASK_USER placeholder, expected none.")

            # 2.e) Plan persistieren
            self.state["todolist_id"] = todolist.todolist_id
            await self.state_manager.save_state(session_id, self.state)
            self.todo_list_manager.update_todolist(todolist)  # persist current version if needed

        else:
            # Es existiert bereits ein Plan (Resume-Fall)
            # Lade ihn (oder nutze deinen bisherigen Helper)
            if hasattr(self.todo_list_manager, "load_todolist_by_id"):
                todolist = await self.todo_list_manager.load_todolist_by_id(self.state["todolist_id"])
            else:
                todolist = await self._create_or_get_todolist(session_id, self.state)

        # --- 3) ReAct Loop über die finale TodoList ------------------------------
        for next_step in todolist.items:
            # Hydratation: Parameter ggf. aus answers einsetzen
            self._hydrate_parameters_from_answers(next_step)

            # 1) Thought
            thought = await self._generate_thought(next_step)
            yield AgentEvent(type=AgentEventType.THOUGHT, data={"for_step": next_step.position, "thought": asdict(thought)})

            # 2) Action
            action = await self._decide_next_action(thought, next_step)
            yield AgentEvent(type=AgentEventType.ACTION, data={"for_step": next_step.position, "action": action.type.value})

            # 3) Execute
            observation = await self._execute_action(action)

            # 4) State aktualisieren
            self.state["last_observation"] = observation
            next_step.status = TaskStatus.COMPLETED if observation.get("success") else TaskStatus.FAILED

            # 5) Persist
            await self.state_manager.save_state(session_id, self.state)
            self.todo_list_manager.update_todolist(todolist)

            # Optional: Early stop bei Fehler + Re-Plan-Hook
            # if not observation.get("success") and self.allow_replan_on_failure:
            #     break / trigger replan...

        # --- 4) Abschluss ---------------------------------------------------------
        yield AgentEvent(type=AgentEventType.COMPLETE, data={"todolist": todolist.to_markdown()})
        return



    async def _create_or_get_todolist(self, session_id: str, state: Dict[str, Any]) -> Optional[TodoList]:
        """
        Creates a new todolist for the mission if no todolist exists yet or loads the existing todolist

        Args:
            session_id: The session id for the agent.
            state: The state of the agent.

        Returns:
            A todolist for the mission.
        """
        todolist_id = state.get("todolist_id")
        # check if a plan has already been created for the mission
        if self.mission is None:
            mission = state.get("last_user_message")

        # check if the todolist is already created
        if not todolist_id:
            todolist = await self.todo_list_manager.create_todolist(mission, self.tools_description)
            state["todolist_id"] = todolist.todolist_id
            await self.state_manager.save_state(session_id, state)

            # update the message history with the new todolist
            system_prompt = build_system_prompt(system_prompt=self.system_prompt, mission=self.mission, todo_list=todolist.to_json())
            self.message_history.replace_system_prompt(system_prompt)

            # add a new message to the message history
            self.message_history.add_message(f"New todolist created: {todolist.to_json()}", "assistant")

            print(f"New todolist created:\n\n{todolist.to_markdown()}")

            return todolist
        else:
            todolist = await self.todo_list_manager.load_todolist(todolist_id)                
            return todolist


    def _get_tools_description(self) -> str:
        """
        Gets the description of the tools available.
        """
        return "\n".join([ f"- {tool.name}: {tool.description}" for tool in self.tools])


    def _get_tools_schema(self) -> List[Dict[str, Any]]:
        """
        Gets the schema of the tools available which can be used as a function calling schema for the LLM.
        """
        return [tool.function_tool_schema for tool in self.tools]


    def _hydrate_parameters_from_answers(self, step: TodoItem) -> None:
        """
        Hydrates the parameters of the step from the answers in the state.

        Args:
            step: The step to hydrate the parameters from the answers.
        """
        answers = self.state.get("answers", {})
        for k, v in list(step.parameters.items()):
            if isinstance(v, str) and v == "ASK_USER":
                if k in answers:
                    step.parameters[k] = answers[k]


    async def _generate_thought(self, next_step: TodoItem) -> Thought:
        """
        ReAct Thought Generation:
        Generates a thought for the next step. A thought is a plan for the next step.
        Therfore the following context is needed:
        - The next step
        - The tools available
        - The history of the agent
        - The system prompt of the agent
        - The mission of the agent
        - The todo list of the agent

        Args:
            next_step: The next step to generate a thought for.

        Returns:
            A thought for the next step. A thought is a plan for the next step which is a JSON object.
        """
        schema_hint = {
            "next_step_ref": "int",
            "rationale": "string (<= 2 sentences)",
            "action": {
                "type": "tool_call|ask_user|complete|update_todolist|error_recovery",
                "tool": "string|null",
                "input": "object",
                "question": "string? (ask_user)",
                "message": "string? (complete)"
            },
            "expected_outcome": "string"
        }

        # get the last 2 messages from the message history. this shall be sufficient for the LLM to plan the next action.
        messages = self.message_history.get_last_n_messages(2)

        messages.append({"role": "user", "content": (
            "You are the Planning & Action Selector.\n"
            "Pick exactly one next action for the next_step below.\n"
            f"NEXT_STEP:\n{next_step.to_json()}\n\n"
            "Prefer tools; ask_user only if info is missing.\n"
            "Return STRICT JSON only (no extra text) matching this schema:\n"
            f"{json.dumps(schema_hint, ensure_ascii=False)}\n\n"
        )})

        response = await litellm.acompletion(
            model="gpt-4.1-mini",
            messages=messages,
            response_format={"type": "json_object"},
            temperature=0.2,
            tools=self.tools_schema,
            tool_choice="auto",
        )

        self.message_history.add_message(response.choices[0].message.content, "assistant")

        return Thought.from_json(response.choices[0].message.content)


    async def _decide_next_action(self, thought: Thought, next_step: TodoItem) -> Action:
        """
        Decides the next action for the next step based on the thought.
        """
        thought_action = thought.action
        if thought_action.type == ActionType.TOOL:
            return Action(
                type=ActionType.TOOL,
                tool=thought_action.tool,
                input=thought_action.input)
        elif thought_action.type == ActionType.ASK:
            return Action(
                type=ActionType.ASK,
                tool=thought_action.tool,
                input=thought_action.input)
        elif thought_action.type == ActionType.DONE:
            return Action(
                type=ActionType.DONE,
                tool=thought_action.tool,
                input=thought_action.input)
        elif thought_action.type == ActionType.PLAN:
            return Action(
                type=ActionType.PLAN,
                tool=thought_action.tool,
                input=thought_action.input)
        elif thought_action.type == ActionType.ERR:
            return Action(
                type=ActionType.ERR,
                tool=thought_action.tool,
                input=thought_action.input)
        else:
            raise ValueError(f"Invalid action type: {thought_action.type}")


    async def _execute_action(self, action: Action) -> str:
        """
        Executes the action for the next step.
        """
        if action.type == ActionType.TOOL:            
            tool = self._get_tool(action.tool)
            if not tool:
                raise ValueError(f"Tool '{action.tool}' not found")

            return await tool.execute(**action.input)
            
        elif action.type == ActionType.ASK:
            pass
        elif action.type == ActionType.DONE:
            pass
        elif action.type == ActionType.PLAN:
            pass
        elif action.type == ActionType.ERR:
            pass
        else:
            raise ValueError(f"Invalid action type: {action.type}")


    def _get_tool(self, tool_name: str) -> Tool:
        """
        Gets the tool from the tools list where the name matches the tool_name
        """

        # check if tool_name starts with functions.
        if tool_name.startswith("functions."):
            tool_name = tool_name[len("functions."):]

        return next((tool for tool in self.tools if tool.name == tool_name), None)


    # create a static method to create an agent
    @staticmethod
    def create_agent(name: str, description: str, system_prompt: str, mission: str, work_dir: str, llm) -> "Agent":
        """
        Creates an agent with the given name, description, system prompt, mission, and work directory.
        The agent will be created with the following tools:
        - WebSearchTool
        - WebFetchTool
        - PythonTool
        - GitHubTool
        - GitTool
        - FileReadTool
        - FileWriteTool
        - PowerShellTool
        The agent will be created with the following planner:
        - TodoListManager
        The agent will be created with the following state manager:
        - StateManager

        Args:
            name: The name of the agent.
            description: The description of the agent.
            system_prompt: The system prompt for the agent.
            mission: The mission for the agent.
            work_dir: The work directory for the agent.
            llm: The llm for the agent.

        Returns:
            An agent with the given name, description, system prompt, mission, and work directory.
        """
        tools = [
            WebSearchTool(),
            WebFetchTool(),
            PythonTool(),
            GitHubTool(),
            GitTool(),
            FileReadTool(),
            FileWriteTool(),
            PowerShellTool(),
        ]

        system_prompt = GENERIC_SYSTEM_PROMPT if system_prompt is None else system_prompt
        work_dir = Path(work_dir)
        work_dir.mkdir(exist_ok=True)

        # todolist directory is work_dir/todolists
        todolist_dir = work_dir / "todolists"
        todolist_dir.mkdir(exist_ok=True)
        planner = TodoListManager(base_dir=todolist_dir)

        # state directory is work_dir/states
        state_dir = work_dir / "states"
        state_dir.mkdir(exist_ok=True)
        state_manager = StateManager(state_dir=state_dir)

        return Agent(name, description, system_prompt, mission, tools, planner, state_manager, llm)


# ============================================
# MAIN ENTRY POINT FOR QUICK DEBUGGING
# ============================================
def main():
    """Minimal entrypoint to construct the Agent and run until thought generation."""
    import os
    import asyncio
    import uuid
    from pathlib import Path

    # Ensure API key for LLM is available
    if not os.getenv("OPENAI_API_KEY"):
        print("Error: Please set OPENAI_API_KEY environment variable before running.")
        return

    name = "AgentV2-Debug"
    description = "Lightweight debug run to reach thought generation."
    system_prompt = GENERIC_SYSTEM_PROMPT

    # Mission: Ask the user for the directory name and the content of the README.txt file, then create the directory and add the README.txt file with the provided content.
    # mission = (        
    #     "Create the directory with the specified name and add a README.txt file inside it containing the provided content."
    #     "Ask the user for the name of the directory to create and the content to put inside a README.txt file. "
    # )
    mission = None

    # Use a local work directory next to this file
    work_dir = str((Path(__file__).parent / ".debug_work").resolve())

    # Create agent
    agent = Agent.create_agent(
        name=name,
        description=description,
        system_prompt=system_prompt,
        mission=mission,
        work_dir=work_dir,
        llm=None,
    )

    # Minimal inputs for execute()
    session_id = f"debug-{uuid.uuid4()}"
    #user_message = "Create a new directory and add a README.txt file inside it containing a hello_world code example."
    user_message = "Create a file"

    print(f"Starting Agent execute() with session_id={session_id}")
    try:
        async def drive():
            current_input = user_message
            done = False
            while True:
                async for ev in agent.execute(user_message=current_input, session_id=session_id):
                    if ev.type.name == AgentEventType.ASK_USER.name:
                        print("QUESTION:", ev.data.get("question"))
                        current_input = input("> ").strip()
                    elif ev.type.name == AgentEventType.STATE_UPDATED.name:
                        print("STATE UPDATED:", ev.data)
                    elif ev.type.name == AgentEventType.COMPLETE.name:
                        print("COMPLETED:")
                        print(ev.data.get("todolist"))
                        done = True
                        # Do NOT break here; let the async generator finish naturally
                        # to avoid cancellation at the yield suspension point.
                if done:
                    # Completed; exit outer loop after the async generator finishes
                    break

        asyncio.run(drive())
        print("Agent session finished.")
    except Exception as exc:
        print(f"Agent execution failed: {exc}")


if __name__ == "__main__":
    main()



// Relative Path: conversation_manager.py
# conversation_manager.py
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field

from capstone.agent_v2.hybrid_agent import HybridAgent


@dataclass
class ConversationManager:
    session_id: str
    agent: HybridAgent
    plan_id: Optional[str] = None
    history: List[Dict[str, Any]] = field(default_factory=list)

    async def start(self, mission: str) -> Dict[str, Any]:
        out = await self.agent.execute(mission, session_id=self.session_id, plan_id=self.plan_id)
        self.plan_id = out.get("plan_id", self.plan_id)
        msgs = out.get("messages")
        if isinstance(msgs, list):
            self.history = msgs
        return out

    async def user_says(self, text: str) -> Dict[str, Any]:
        out = await self.agent.execute(
            session_id=self.session_id,
            plan_id=self.plan_id,
            user_message=text,
        )
        self.plan_id = out.get("plan_id", self.plan_id)
        msgs = out.get("messages")
        if isinstance(msgs, list):
            self.history = msgs
        return out




// Relative Path: statemanager.py

# ==================== STATE MANAGEMENT ====================

from datetime import datetime
from pathlib import Path
import pickle
import time
from typing import Dict, Optional

import structlog


class StateManager:
    """Manages agent state persistence and recovery"""
    
    def __init__(self, state_dir: str = "./agent_states"):
        self.state_dir = Path(state_dir)
        self.state_dir.mkdir(exist_ok=True)
        self.logger = structlog.get_logger()
    
    async def save_state(self, session_id: str, state_data: Dict) -> bool:
        """Save agent state asynchronously"""
        try:
            state_file = self.state_dir / f"{session_id}.pkl"
            
            state_to_save = {
                'session_id': session_id,
                'timestamp': datetime.now().isoformat(),
                'state_data': state_data
            }
            
            # Async file write
            import aiofiles
            async with aiofiles.open(state_file, 'wb') as f:
                await f.write(pickle.dumps(state_to_save))
            
            self.logger.info("state_saved", session_id=session_id)
            return True
            
        except Exception as e:
            self.logger.error("state_save_failed", session_id=session_id, error=str(e))
            return False
    
    async def load_state(self, session_id: str) -> Optional[Dict]:
        """Load agent state asynchronously"""
        try:
            state_file = self.state_dir / f"{session_id}.pkl"
            
            if not state_file.exists():
                return {}
            
            import aiofiles
            async with aiofiles.open(state_file, 'rb') as f:
                content = await f.read()
                state = pickle.loads(content)
            
            self.logger.info("state_loaded", session_id=session_id)
            return state['state_data']
            
        except Exception as e:
            self.logger.error("state_load_failed", session_id=session_id, error=str(e))
            return None
    
    def cleanup_old_states(self, days: int = 7):
        """Remove states older than specified days"""
        cutoff_time = time.time() - (days * 24 * 60 * 60)
        
        for state_file in self.state_dir.glob("*.pkl"):
            if state_file.stat().st_mtime < cutoff_time:
                state_file.unlink()
                self.logger.info("old_state_removed", file=state_file.name)



// Relative Path: taskforce_cli.py
# taskforce_cli.py
import asyncio
import os
import argparse
from capstone.agent_v2.conversation_manager import ConversationManager
from capstone.agent_v2.hybrid_agent import HybridAgent

async def main():
    parser = argparse.ArgumentParser(description="TaskForce CLI")
    parser.add_argument("--mission", type=str, default=None, help="Initial mission text")
    parser.add_argument("--model", type=str, default=os.getenv("OPENAI_MODEL", "gpt-4.1-mini"))
    parser.add_argument("--temperature", type=float, default=float(os.getenv("OPENAI_TEMPERATURE", 0.7)))
    args = parser.parse_args()

    api_key = os.getenv("OPENAI_API_KEY")
    agent = HybridAgent(
        api_key=api_key,
        model=args.model,
        enable_planning=True,
        plan_save_dir="./execution_plans",
        temperature=args.temperature,
    )

    cm = ConversationManager(session_id="local-cli", agent=agent)
    await cm.start(args.mission)

    print("TaskForce-CLI. Type 'exit' to quit.")
    while True:
        user = input("You: ").strip()
        if user.lower() in {"exit", "quit"}:
            break

        result = await cm.user_says(user)

        if result.get("needs_user_input") and result.get("question"):
            print(f"Agent needs info: {result['question']}")
            continue

        # Show tool-results (compact)
        rlist = result.get("results", [])
        if rlist:
            for r in rlist:
                ok = "✓" if r["success"] else "✗"
                print(f"[{ok}] {r['tool']} -> {str(r['result'])[:140]}")

        # Also print the last assistant message (if any)
        for m in reversed(cm.history):
            if m["role"] == "assistant":
                print(f"Agent: {m['content'][:800]}")
                break

if __name__ == "__main__":
    asyncio.run(main())




// Relative Path: tool.py
# ============================================
# BASE TOOL INTERFACE
# ============================================

from abc import ABC, abstractmethod
import inspect
from typing import Any, Optional, Dict, List, Tuple


class Tool(ABC):
    """Base class for all tools"""
    
    @property
    @abstractmethod
    def name(self) -> str:
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        pass
    
    @property
    def parameters_schema(self) -> Dict[str, Any]:
        """Override to provide custom parameter schema for OpenAI function calling"""
        return self._generate_schema_from_signature()
    
    def _generate_schema_from_signature(self) -> Dict[str, Any]:
        """Auto-generate parameter schema from execute method signature"""
        sig = inspect.signature(self.execute)
        properties = {}
        required = []
        
        for param_name, param in sig.parameters.items():
            if param_name in ['self', 'kwargs']:
                continue
            
            # Determine parameter type
            param_type = "string"  # Default
            param_desc = f"Parameter {param_name}"
            
            if param.annotation != inspect.Parameter.empty:
                if param.annotation == int:
                    param_type = "integer"
                elif param.annotation == bool:
                    param_type = "boolean"
                elif param.annotation == float:
                    param_type = "number"
                elif param.annotation == Dict or param.annotation == dict:
                    param_type = "object"
                elif param.annotation == List or param.annotation == list:
                    param_type = "array"
            
            properties[param_name] = {
                "type": param_type,
                "description": param_desc
            }
            
            # Check if required
            if param.default == inspect.Parameter.empty:
                required.append(param_name)
        
        return {
            "type": "object",
            "properties": properties,
            "required": required
        }

    @property
    def function_tool_schema(self) -> Dict[str, Any]:
        """Return full OpenAI function tool schema for this tool."""
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.parameters_schema,
            },
        }
    
    @abstractmethod
    async def execute(self, **kwargs) -> Dict[str, Any]:
        pass
    
    def validate_params(self, **kwargs) -> Tuple[bool, Optional[str]]:
        """Validate parameters before execution"""
        sig = inspect.signature(self.execute)
        
        for param_name, param in sig.parameters.items():
            if param_name in ['self', 'kwargs']:
                continue
            
            if param.default == inspect.Parameter.empty and param_name not in kwargs:
                return False, f"Missing required parameter: {param_name}"
        
        return True, None




