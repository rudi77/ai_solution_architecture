<!DOCTYPE html>
<html>
<head>
<title>report.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p>Here’s a <strong>much more detailed technical report</strong> on your <strong>TaskForce Agent Framework</strong>—with an expanded introduction, deep component breakdown (including <code>TodoListManager</code>), end-to-end execution flow (pre-clarification → planning → ReAct), and C4 Mermaid diagrams. I’ve grounded key details with short source citations to your uploaded code.</p>
<hr>
<h1 id="technical-report--taskforce-agent-framework">Technical Report — TaskForce Agent Framework</h1>
<h2 id="introduction--motivation">Introduction &amp; Motivation</h2>
<p>I built <strong>TaskForce</strong> to move beyond “agent as a black box” and truly understand how agents <strong>plan</strong>, <strong>call tools</strong>, and <strong>consistently execute</strong> real-world tasks. Building an agent that (a) extracts missing inputs up front, (b) creates a <strong>deterministic plan</strong>, and (c) <strong>faithfully</strong> carries out that plan with multiple tools turned out to be far tougher than expected—especially around <strong>clarification timing</strong>, <strong>state management</strong>, and <strong>tool parameterization</strong>. TaskForce is both a framework and a learning journey toward <strong>transparent, modular, developer-friendly</strong> AI agents.</p>
<hr>
<h2 id="executive-summary">Executive Summary</h2>
<p><strong>TaskForce</strong> is a CLI-first, LLM-orchestrated agent that:</p>
<ul>
<li>Collects missing inputs with a <strong>Pre-Clarification</strong> pass. </li>
<li>Generates a <strong>No-ASK</strong> final plan (a strict Todo List) and hard-fails if any <code>ASK_USER</code> placeholders remain.  </li>
<li>Executes the plan in a <strong>ReAct</strong> loop: for each step, generate a Thought → decide one Action → run a Tool → record Observation, possibly trigger <code>ask_user</code>.   </li>
</ul>
<hr>
<h1 id="architecture">Architecture</h1>
<h2 id="c4--context">C4 — Context</h2>
<pre><code class="language-mermaid"><div class="mermaid">C4Context
    title TaskForce — Context
    Person(dev, "Developer/User", "Describes a mission, answers clarifying questions")
    System(taskforce, "TaskForce CLI/Agent", "Plans and executes missions with tools")

    System_Ext(llm, "LLM Provider", "Chat Completions / Function Calling")
    System_Ext(vcs, "GitHub/Azure DevOps", "Repos, PAT/SSH")
    System_Ext(fs, "Local Filesystem", "Workspace, artifacts, logs")

    Rel(dev, taskforce, "Provide mission, answer asks")
    Rel(taskforce, llm, "Prompting & tool schemas")
    Rel(taskforce, vcs, "git & API operations")
    Rel(taskforce, fs, "Read/Write artifacts")
</div></code></pre>
<h2 id="c4--container">C4 — Container</h2>
<pre><code class="language-mermaid"><div class="mermaid">C4Container
    title TaskForce — Container View
    System(taskforce, "TaskForce")

    Container(cli, "CLI / Conversation", "Typer/Rich", "Starts sessions, streams events, persists history")
    Container(agent, "Agent Core", "Python async", "Pre-clarify → Plan → ReAct")
    Container(tools, "Tool Registry", "Python modules", "Tool interface + concrete tools")
    Container(state, "State Manager", "Pickle + aiofiles", "Persist & resume session state")
    Container(work, "Workspace", "Filesystem", "TodoLists, artifacts, logs")

    Rel(cli, agent, "execute(mission|user_message)")
    Rel(agent, tools, "call Tool.execute(...)")
    Rel(agent, state, "save_state/load_state")
    Rel(agent, work, "read/write todolist & artifacts")
</div></code></pre>
<h2 id="c4--component-agent-core">C4 — Component (Agent Core)</h2>
<pre><code class="language-mermaid"><div class="mermaid">C4Component
    title TaskForce — Agent Core Components

    Container(agent, "Agent Core", "Orchestration")

    Component(conv, "Conversation Manager", "Keeps plan_id & history; forwards user input")
    Component(todos, "TodoListManager", "Clarification Qs, final plan (No-ASK), R/W storage")
    Component(exec, "ReAct Executor", "Thought → Action → Tool → Observation loop")
    Component(state, "StateManager", "Async persist/load/cleanup")
    Component(tools, "Tool Layer", "Base Tool interface, schemas, concrete tools")
    Component(prompt, "System Prompt Builder", "Base + Mission + TodoList")

    Rel(conv, agent, "start()/user_says()")
    Rel(agent, todos, "extract Qs / create plan / update")
    Rel(agent, exec, "iterate steps")
    Rel(agent, state, "persist session, answers, observations")
    Rel(agent, tools, "invoke execute(...)")
    Rel(agent, prompt, "build/replace system prompt")
</div></code></pre>
<hr>
<h1 id="components-in-depth">Components in Depth</h1>
<h2 id="conversation-manager-cliux-shell">Conversation Manager (CLI/UX Shell)</h2>
<ul>
<li>Holds <code>session_id</code>, <code>plan_id</code>, and <code>history</code>. Delegates to <code>agent.execute(...)</code> for both starting a mission and processing subsequent user replies; updates stored history and plan id from the agent’s return.  </li>
<li>The sample driver loop streams agent events (ASK_USER, STATE_UPDATED, COMPLETE) and lets the user answer questions interactively. </li>
</ul>
<h2 id="state-manager">State Manager</h2>
<ul>
<li><strong>Async</strong> persistence (<code>aiofiles</code> + <code>pickle</code>) of session state: <code>answers</code>, <code>pending_question</code>, <code>todolist_id</code>, <code>last_observation</code>, etc.  </li>
<li>Housekeeping: removal of old state files. </li>
</ul>
<h2 id="tool-layer">Tool Layer</h2>
<ul>
<li><strong>Base interface</strong> (<code>Tool</code>) with auto-generated <strong>parameter schema</strong> inferred from the tool’s <code>execute</code> signature—enables function-calling/tool-calling with correct JSON.  </li>
<li>Concrete tools used by the agent include <code>PythonTool</code>, <code>FileReadTool</code>, <code>FileWriteTool</code>, <code>GitHubTool</code>, <code>GitTool</code>, <code>PowerShellTool</code>, <code>WebSearchTool</code>, <code>WebFetchTool</code>. </li>
<li>Example: <code>WebFetchTool</code> fetches URLs with timeout and lightweight HTML extraction; returns structured content.  </li>
<li><code>AskUserTool</code> is first-class to surface a <strong>single, crisp</strong> question to the user. </li>
</ul>
<h2 id="system-prompt--policy">System Prompt &amp; Policy</h2>
<ul>
<li>
<p>A <strong>generic system prompt</strong> encodes core principles:</p>
<ul>
<li><strong>Plan first</strong>, <strong>Clarify early</strong> (use <code>ASK_USER</code> placeholders during planning), <strong>Prefer tools</strong>, <strong>Update state</strong> after each step. </li>
<li>Decision policy: <strong>tools &gt; ask_user &gt; stop</strong>; never assume implicit values. </li>
</ul>
</li>
<li>
<p>The runtime system prompt is built from <strong>Base + Mission + TodoList</strong> sections and can be <strong>replaced</strong> once a plan is produced to provide the model with the current plan.  </p>
</li>
</ul>
<h2 id="todolistmanager-planning">TodoListManager (Planning)</h2>
<p><strong>Purpose.</strong> Turn a mission + tools into a <strong>strict, executable plan</strong> (TodoList), with a two-phase strategy:</p>
<ol>
<li>
<p><strong>Pre-Clarification (Ask-User phase).</strong></p>
<ul>
<li>Extract missing inputs as a <strong>JSON array</strong> of closed, unambiguous questions keyed by stable identifiers (prefer <code>&lt;tool&gt;.&lt;parameter&gt;</code>).  </li>
<li>Deterministic prompting (<code>temperature=0</code>) to avoid drift; strict JSON parsing with robust error handling.  </li>
</ul>
</li>
<li>
<p><strong>Final TodoList (No-ASK mode).</strong></p>
<ul>
<li>Build a final plan with <strong>no open questions</strong> and <strong>no <code>ASK_USER</code></strong> placeholders—enforced via <strong>quality checks</strong>.  </li>
<li>Writes/reads the TodoList JSON to disk; supports <code>get</code>, <code>update</code>, <code>delete</code>, and deterministic pathing.    </li>
</ul>
</li>
</ol>
<p><strong>Plan as “Manus-style” TodoList.</strong> Each item is <strong>atomic</strong>, single-responsibility, with <code>tool</code>, <code>parameters</code>, <code>depends_on</code>, and <code>status</code>. The manager also provides markdown rendering for visibility.  </p>
<p>Perfekt – ich ergänze deinen technischen Bericht um ein eigenes Kapitel <strong>“Tools”</strong>, das beschreibt, <strong>wie Tools in TaskForce aufgerufen werden</strong>, wie die Schnittstelle aussieht und wie die Einbettung in die ReAct-Loop funktioniert. Ich baue die Erklärung auf deinen Codefundamenten (<code>Tool</code>-Basisklasse, automatische Parameter-Schemata, Tool-Registry, ReAct-Executor) auf.</p>
<hr>
<h1 id="tools-in-taskforce">Tools in TaskForce</h1>
<h2 id="design-principles">Design Principles</h2>
<ul>
<li><strong>Uniform Interface</strong>: Every tool inherits from a base <code>Tool</code> class with a common <code>execute(...)</code> signature.</li>
<li><strong>Schema-Driven</strong>: The framework auto-generates a JSON Schema for each tool’s parameters from its Python type hints. This enables LLMs to call tools through structured <strong>function calling</strong>.</li>
<li><strong>First-Class Actions</strong>: In the ReAct loop, <code>tool_call</code> is one of the limited allowed action types (<code>tool_call | ask_user | complete | update_todolist | error_recovery</code>).</li>
<li><strong>Explicitness</strong>: Tools never take implicit parameters. If an argument is missing, the agent must first ask the user (via <code>AskUserTool</code>) before calling.</li>
</ul>
<hr>
<h2 id="tool-lifecycle-in-the-agent">Tool Lifecycle in the Agent</h2>
<h3 id="1-planning-phase">1. Planning Phase</h3>
<p>When the <code>TodoListManager</code> builds a plan, each step explicitly names:</p>
<ul>
<li>the <strong>tool</strong> to invoke,</li>
<li>the <strong>parameters</strong> required,</li>
<li>and the <strong>expected outcome</strong>.</li>
</ul>
<p>If any parameters are unknown, the placeholder <code>ASK_USER</code> is inserted, and the plan cannot pass validation until all are resolved.</p>
<hr>
<h3 id="2-decision-react-thoughtaction">2. Decision (ReAct Thought/Action)</h3>
<p>At runtime, the agent generates a <strong>Thought</strong> that selects one tool and prepares the <strong>Action</strong>:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"next_step_ref"</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">"rationale"</span>: <span class="hljs-string">"We need to fetch the URL content before processing"</span>,
  <span class="hljs-attr">"action"</span>: {
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"tool_call"</span>,
    <span class="hljs-attr">"tool"</span>: <span class="hljs-string">"WebFetchTool"</span>,
    <span class="hljs-attr">"input"</span>: { <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://example.com"</span> }
  },
  <span class="hljs-attr">"expected_outcome"</span>: <span class="hljs-string">"HTML content of the page"</span>
}
</div></code></pre>
<hr>
<h3 id="3-execution">3. Execution</h3>
<ul>
<li>
<p>The framework dispatches the call via the <code>Tool</code> interface:</p>
<pre class="hljs"><code><div>result = <span class="hljs-keyword">await</span> tool.execute(**parameters)
</div></code></pre>
</li>
<li>
<p>Success/failure is wrapped into an <strong>Observation</strong> event, streamed back to the CLI:</p>
<ul>
<li><code>TOOL_STARTED</code></li>
<li><code>TOOL_RESULT {success, result, error}</code></li>
</ul>
</li>
</ul>
<p>If execution fails, the agent may attempt <strong>error_recovery</strong> (retry, adjust input, or ask the user).</p>
<hr>
<h3 id="4-integration-with-state">4. Integration with State</h3>
<ul>
<li>The <strong>last observation</strong> is persisted into the session state.</li>
<li>If the tool indicated <code>requires_user = True</code>, the agent emits <code>ASK_USER</code> and stores <code>pending_question {answer_key, question}</code>.</li>
<li>The next loop iteration hydrates TodoList parameters with the user’s answer.</li>
</ul>
<hr>
<h2 id="example-tools">Example Tools</h2>
<ul>
<li>
<p><strong>File Tools</strong>:</p>
<ul>
<li><code>FileReadTool(path) → str</code></li>
<li><code>FileWriteTool(path, content)</code></li>
</ul>
</li>
<li>
<p><strong>Code Execution</strong>:</p>
<ul>
<li><code>PythonTool(code) → stdout/err</code></li>
</ul>
</li>
<li>
<p><strong>System / DevOps</strong>:</p>
<ul>
<li><code>GitTool</code> (clone, commit, push)</li>
<li><code>PowerShellTool(command)</code></li>
</ul>
</li>
<li>
<p><strong>Web</strong>:</p>
<ul>
<li><code>WebSearchTool(query)</code></li>
<li><code>WebFetchTool(url, timeout)</code> with lightweight HTML parsing</li>
</ul>
</li>
<li>
<p><strong>Meta</strong>:</p>
<ul>
<li><code>AskUserTool(question)</code> to pause execution and obtain required inputs</li>
</ul>
</li>
</ul>
<p>All follow the same <strong>schema-based execution contract</strong>, making them interchangeable building blocks in plans.</p>
<hr>
<h2 id="why-this-matters">Why This Matters</h2>
<ul>
<li><strong>LLM Reliability</strong>: By giving the model <strong>strict tool schemas</strong>, hallucinated or malformed calls are minimized.</li>
<li><strong>Traceability</strong>: Each tool call is logged as a separate event with parameters and results.</li>
<li><strong>Extensibility</strong>: New tools can be added by subclassing <code>Tool</code>; the schema is auto-extracted from type hints, so the agent knows immediately how to call them.</li>
</ul>
<hr>
<h1 id="end-to-end-flow">End-to-End Flow</h1>
<h2 id="1-pre-clarification-pass-ask-user-before-planning">1) Pre-Clarification Pass (“Ask User” before planning)</h2>
<ul>
<li>If there’s no existing plan, the agent first <strong>extracts clarification questions</strong>; if any are unanswered, it yields an <strong>ASK_USER</strong> event and <strong>pauses</strong> execution. The question is stored with a <strong>stable key</strong> (<code>answer_key</code>) so the reply can be merged back into <code>answers</code>.  </li>
<li>At the CLI, you print the question and collect user input (the driver loop shows this interaction). </li>
</ul>
<h2 id="2-final-plan-creation-no-ask-mode">2) Final Plan Creation (No-ASK mode)</h2>
<ul>
<li>After <strong>all questions are answered</strong>, the agent requests a <strong>strict final TodoList</strong> from <code>TodoListManager.create_todolist(...)</code> using those answers; <strong>hard guardrails</strong> reject any residual <code>ASK_USER</code> or <code>open_questions</code>. The plan is then <strong>persisted</strong>, and the system prompt is <strong>refreshed</strong> with the new TodoList.   </li>
</ul>
<h2 id="3-react-execution-loop">3) ReAct Execution Loop</h2>
<p>For each Todo step:</p>
<ol>
<li>
<p><strong>Thought</strong> — The agent asks the LLM to produce a <strong>single next action</strong> (schema-constrained), with a short rationale and expected outcome. Context includes the <strong>next step</strong>, <strong>tools</strong>, <strong>history</strong>, <strong>system prompt</strong>, <strong>mission</strong>, <strong>todo list</strong>, plus <strong>recent state</strong> (<code>answers</code>, <code>last_observation</code>).   </p>
<ul>
<li>The action types are strictly limited: <code>tool_call | ask_user | complete | update_todolist | error_recovery</code>. Prefer tools; only <code>ask_user</code> if info is missing.   </li>
</ul>
</li>
<li>
<p><strong>Action</strong> — Decide and emit exactly one action (event stream includes THOUGHT/ACTION).  </p>
</li>
<li>
<p><strong>Tool Execution</strong> — Invoke the tool; capture <strong>Observation</strong> with <code>success/error/data</code> and whether it <strong>requires_user</strong> (to trigger a question).  </p>
<ul>
<li>If a user answer is needed mid-plan, set <code>pending_question {answer_key, question}</code> in state, <strong>ASK_USER</strong>, and pause. </li>
</ul>
</li>
<li>
<p><strong>State Update &amp; Hydration</strong> — Store <code>last_observation</code>, and (if you re-enable it) <strong>hydrate</strong> upcoming step parameters from <code>answers</code> (replace <code>ASK_USER</code> with real values).   </p>
</li>
</ol>
<p>The event model supports <code>THOUGHT</code>, <code>ACTION</code>, <code>TOOL_STARTED</code>, <code>TOOL_RESULT</code>, <code>ASK_USER</code>, <code>STATE_UPDATED</code>, <code>COMPLETE</code>, <code>ERROR</code>, which the CLI can stream elegantly.  </p>
<hr>
<h1 id="what-the-framework-can-do-today">What the Framework Can Do (Today)</h1>
<ul>
<li><strong>Turn natural language missions</strong> into <strong>deterministic plans</strong> and execute them step-by-step with <strong>multiple tools</strong>. </li>
<li><strong>Ask all necessary questions up front</strong> (and on demand during execution) with stable keys for structured answers. </li>
<li><strong>Use a rich toolset</strong> (code, file I/O, git, web, shell) with <strong>auto-generated schemas</strong> to reduce tool-call errors.  </li>
<li><strong>Persist/Resume</strong> sessions via the <code>StateManager</code> to keep progress, answers, and observations. </li>
<li><strong>Stream events</strong> to a CLI loop so users can watch thoughts/actions and answer questions in real time. </li>
</ul>
<hr>
<h1 id="strengths">Strengths</h1>
<ol>
<li><strong>Plan-First Discipline</strong> — The agent refuses to execute until the plan is <strong>strict</strong> (no <code>ASK_USER</code>, no open questions). This drastically improves determinism. </li>
<li><strong>Clarification Quality</strong> — Questions are <strong>closed</strong>, <strong>typed</strong>, and tied to <strong>tool parameters</strong>; answers merge back cleanly using stable keys. </li>
<li><strong>ReAct Done Right</strong> — One action per step, schema-constrained, with <strong>short rationales</strong> and <strong>clear stop conditions</strong>.  </li>
<li><strong>Tooling Ergonomics</strong> — The base <code>Tool</code> infers JSON schemas from Python signatures, minimizing mismatch between prompts and code. </li>
<li><strong>Transparent State</strong> — <code>answers</code>, <code>pending_question</code>, <code>todolist_id</code>, <code>last_observation</code> stored per session for robust handoffs.  </li>
</ol>
<hr>
<h1 id="current-weaknesses-and-why">Current Weaknesses (and Why)</h1>
<ul>
<li><strong>Plan Fragility under Ambiguity.</strong> If missions are vague, the model may miss an edge-case question; adding tool-schema constraints helps, but it’s still an LLM problem. (Your guardrails catch most—but not all—cases.) </li>
<li><strong>Mid-Execution Clarifications.</strong> While supported, pausing and resuming can create branching state; hydration must be consistently applied (currently commented in one spot). </li>
<li><strong>Tool Policy Consistency.</strong> You import both CLI and API-style git tooling; policy rules (e.g., setting remotes, push behavior) live in the Thought prompt—good, but brittle. Consider centralizing enforcement. </li>
<li><strong>Limited Observability Beyond CLI.</strong> Great event model, but no web dashboard/log indexing yet—harder to triage failures in larger runs. (No direct code ref; architectural gap.)</li>
</ul>
<hr>
<h1 id="roadmap-focused">Roadmap (Focused)</h1>
<p><strong>Short-Term</strong></p>
<ul>
<li>Harden <strong>question mining</strong> by validating against tool <strong>required</strong> params and enums (already started in your prompt template). </li>
<li>Enforce a <strong>single source of truth</strong> for git remote/branch policy in a <code>GitPolicy</code> helper, instead of embedding in prompts. </li>
<li>Re-enable and test <strong>parameter hydration</strong> after <code>ASK_USER</code> mid-execution. </li>
</ul>
<p><strong>Long-Term</strong></p>
<ul>
<li>Add a <strong>dashboard</strong> (events, diffs, artifacts) and <strong>structured run logs</strong> to support audits.</li>
<li>Expand <strong>resume</strong> semantics (resume at step N, skip passed steps, re-plan upon failures).</li>
<li>Integrate <strong>multi-agent</strong> modes (planner/executor/judge separation with arbitration).</li>
</ul>
<hr>
<h2 id="appendix--developer-notes">Appendix — Developer Notes</h2>
<h3 id="building-the-system-prompt-at-runtime">Building the System Prompt at Runtime</h3>
<ul>
<li><code>build_system_prompt(Base, Mission, TodoList)</code> creates a <strong>single system message</strong> that always encodes the <strong>latest plan</strong>; when a new TodoList is created, the prompt is <strong>replaced</strong> and the plan is added to the history for visibility.  </li>
</ul>
<h3 id="thought--action-data-model">Thought / Action Data Model</h3>
<ul>
<li><code>ThoughtAction</code> and <code>Thought</code> are dataclasses with strict enums for action types. This keeps the LLM outputs <strong>parseable</strong> and narrows agent behavior.  </li>
</ul>
<h3 id="event-streaming--cli">Event Streaming &amp; CLI</h3>
<ul>
<li>The provided driver shows how to <strong>iterate async events</strong>, prompt the user on <code>ASK_USER</code>, and print final TodoList on <code>COMPLETE</code>. Easy to swap the console for a TUI/GUI later. </li>
</ul>

</body>
</html>
